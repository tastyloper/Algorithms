/**
 * 후보키
 *
 * 프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다.
 * 
 * 그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고,
 * 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다.
 * 
 * 후보키에 대한 내용이 잘 기억나지 않던 제이지는,
 * 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다.
 *  * 관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을
 *    유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.
 *    * 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.
 *    * 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다.
 *      즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.
 * 
 * 제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.
 * 
 * 제한 사항
 * 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.
 * stages의 길이는 1 이상 200,000 이하이다.
 * stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.
 * 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
 * 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
 * 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
 * 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.
 *
 * Example 1:
 * Input: 5, [2, 1, 2, 6, 2, 4, 3, 3]
 * Output: [3,4,2,1,5]
 *
 * Example 2:
 * Input: 4, [4,4,4,4,4]
 * Output: [4,1,2,3]
 * 
 * Clarification:
 * 입출력 예 #1
 * 1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.
 * - 1 번 스테이지 실패율 : 1/8
 * 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.
 * - 2 번 스테이지 실패율 : 3/7
 * 마찬가지로 나머지 스테이지의 실패율은 다음과 같다.
 * - 3 번 스테이지 실패율 : 2/4
 * - 4번 스테이지 실패율 : 1/2
 * - 5번 스테이지 실패율 : 0/1
 * 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.
 * - [3,4,2,1,5]
 * 
 * 입출력 예 #2
 * 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.
 * - [4,1,2,3]
 *
 * https://programmers.co.kr/learn/courses/30/lessons/42889?language=javascript
 */

/**
 * @param {number} N
 * @param {number[]} stages
 * @return {number[]}
 */
const solution = (N, stages) => {
  let leng = 0;
  let failureRate = [];
  for (let i = 1; i <= N; i++) {
    leng = stages.length;
    stages = stages.filter(v => i !== v);
    failureRate = [...failureRate, { stage: i, rate: leng ? (leng - stages.length) / leng : 0 }];
  }
  return failureRate.sort((a, b) => {
    return b.rate === a.rate ? a.stage - b.stage : b.rate - a.rate;
  }).map(v => v.stage);
};

console.log(solution(5, [2, 1, 2, 6, 2, 4, 3, 3]));
console.log(solution(4, [4,4,4,4,4]));
